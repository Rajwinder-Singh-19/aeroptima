"""
bezier.spline
=============

Interpolating shapes using cubic bezier splines
"""

import numpy as np
from scipy.optimize import minimize
from bezier.cubic import cubic_bezier_curve


def __residuals(flat_control_points: np.ndarray, curve_data: np.ndarray) -> float:
    """
    Calculates the normal distance between the original curve points and
    the curve points generated by bezier approximation.

    PARAMETERS:

        `flat_control_points` -> The control points of the bezier curve,
        flattened to a single dimension to allow for curve_fit to optimize. Type(np.ndarray)

        `curve_data` -> Original curve data. Type(np.ndarray)

    RETURNS:
        `np.sum(np.linalg.norm(bezier_points - curve_data))` -> Normal distance between bezier and actual curve. Type(float)

    """
    num_points = len(curve_data)
    control_points = np.array(flat_control_points.reshape(4, 2))
    bezier_points = cubic_bezier_curve(*control_points, n_points=num_points)
    return np.sum(np.linalg.norm(bezier_points - curve_data))


def __fit_bezier(curve_data: np.ndarray, method: str) -> np.ndarray:
    """
    Curve fits the orignal curve data into a bezier curve.
    The returned control points can be used to generate bezier curve

    PARAMETERS:

        `curve_data` -> Original curve data. Type(np.ndarray)

        `method` -> Optimization method used to curve_fit the data. Type(str)

    RETURNS:

        `result.x.reshape(4, 2)` -> Returns the control points for the bezier curve.
        Optimization only returns a flattened list of points.
        Reshapes makes them usable to generate bezier curves. Type(np.ndarray)

    """
    P0 = curve_data[0]
    P3 = curve_data[-1]
    P1 = curve_data[len(curve_data) // 3]
    P2 = curve_data[2 * len(curve_data) // 3]

    result = minimize(
        __residuals,
        np.array([P0, P1, P2, P3]).flatten(),
        args=(curve_data,),
        method=method,
        tol=1e-15,
    ).x

    return result.reshape(4, 2)


def __split_data(curve_data: np.ndarray, num_segments: int) -> list[np.ndarray]:
    """
    Divides the whole curve into different segments, each of which can be bezier interpolated to form a spline.

    PARAMETERS:

        `curve_data` -> Original curve data. Type(np.ndarray)

        `num_segments` -> Number of segments. Type(int)

    RETURNS:

        `[curve_data[i : i + segment_size + 1] for i in range(0, len(curve_data), segment_size)]` -> list of divided curve coordinates. Type(np.ndarray)

    """
    segment_size = len(curve_data) // num_segments
    return [
        curve_data[i : i + segment_size + 1]
        for i in range(0, len(curve_data), segment_size)
    ]


def __enforce_c0_continuity(control_points: np.ndarray) -> np.ndarray:
    """
    Enforces C0 continuity where each segment endpoints are connected.

    PARAMETERS:

        `control_points` -> Control points of all the segments of the curve. Type(np.ndarray)

    RETURNS:

        `control_points` -> C0 continuous control points where all segments are well connected. Type(np.ndarray)

    """
    for i in range(control_points.shape[2] - 1):  # Iterate over segments
        control_points[0, :, i + 1] = control_points[3, :, i]  # Match end to start
    return control_points


def __enforce_c1_continuity(control_points: np.ndarray) -> np.ndarray:
    """
    Enforces C1 continuity where each segment endpoint tangents are aligned.

    PARAMETERS:

        `control_points` -> Control points of all the segments of the curve. Type(np.ndarray)

    RETURNS:

        `control_points` -> C1 continuous control points where all segment tangents are aligned. Type(np.ndarray)

    """
    for i in range(control_points.shape[2] - 1):  # Iterate over segments
        # Compute the tangent at the end of the current segment
        tangent = control_points[3, :, i] - control_points[2, :, i]
        # Adjust the tangent of the next segment
        control_points[1, :, i + 1] = control_points[0, :, i + 1] + tangent
    return control_points


def __enforce_c2_continuity(control_points: np.ndarray) -> np.ndarray:
    """
    Enforces C2 continuity (smooth second derivative) across BÃ©zier curve segments.

    PARAMETERS:

        `control_points` -> Control points of all the segments of the curve. Type(np.ndarray)

    RETURNS:
        `control_points` -> Modified control points with enforced C2 continuity. Type(np.ndarray)
    """
    num_segments = control_points.shape[2]

    for i in range(num_segments - 1):  # Iterate over each segment boundary
        # Compute the curvature condition
        p_prev = control_points[2, :, i]  # Third control point of the current segment
        p_next = control_points[
            0, :, i + 1
        ]  # First control point of the next segment (C0 already enforced)
        p_end = control_points[3, :, i]  # End point of the current segment
        """p_start = control_points[
            1, :, i + 1
        ]"""  # Second control point of the next segment

        # Adjust the second control point of the next segment for C2 continuity
        control_points[1, :, i + 1] = 2 * p_next - p_prev - (p_end - p_next)

    return control_points


def __enforce_continuity(control_points: np.ndarray) -> np.ndarray:
    """
    Wrapper function to enforce C0, C1 and C2 continuity

    PARAMETERS:

        `control_points` -> Control points of all the segments of the curve

    RETURNS:
        `control_points` -> C0, C1 and C2 continuous control points

    """
    control_points = __enforce_c0_continuity(control_points)
    control_points = __enforce_c1_continuity(control_points)
    control_points = __enforce_c2_continuity(control_points)
    return control_points


def get_control_tensor(
    curve_data: np.ndarray, num_segments: int, method: str
) -> np.ndarray:
    """
    Calculates a (4 x 2 x number of segments) array which contains control points for all segments of the cubic bezier spline

    PARAMETERS:

        `curve_data` -> Coordinates of the curve to be modelled using bezier spline. Type(np.ndarray)

        `num_segments` -> Number of segments in the cubic spline. Type(int)

        `method` -> Optimization method used to curve_fit the data. Type(str)

    RETURN:

        `control_tensor` -> (4(control points of cubic bezier) by 2(x and y coordinates) by number of segments) array
        which contains control points for all segments of the cubic bezier spline. Type(np.ndarray)
    """
    control_tensor = np.zeros(shape=(4, 2, num_segments))
    for i in range(0, num_segments):
        control_tensor[:, :, i] = __fit_bezier(
            __split_data(curve_data, num_segments)[i], method=method
        )

    control_tensor[0, :, 0] = curve_data[0]
    control_tensor[-1, :, -1] = curve_data[-1]

    control_tensor = __enforce_continuity(control_tensor)
    return control_tensor


def bezier_spline(control_tensor: np.ndarray, p_per_seg: int) -> np.ndarray:
    """
    Generates the coordinate points of the bezier spline with all the segments connected

    PARAMETERS:

        `control_tensor` -> (4(control points of cubic bezier) by 2(x and y coordinates) by number of segments) array
        which contains control points for all segments of the cubic bezier spline. Type(np.ndarray)

        `p_per_seg` -> Number of points in each segment. Type(int)

    RETURNS:

        `np.vstack(curves)` -> Array of all the points of the cubic bezier spline. Type(np.ndarray)

    """
    curves = [
        cubic_bezier_curve(*control_tensor[:, :, i], n_points=p_per_seg)
        for i in range(control_tensor.shape[2])
    ]
    return np.vstack(curves)
